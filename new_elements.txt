λ                                      = lambda - λ...;
ƛ                                      = lambda that automatically gets mapped - ƛ...;
¬  (any a) -> num                      = logical NOT (non-vectorising)
∧  (any a, any b) -> num               = logical AND
⟑  (any a, any b) -> num               = logical AND with reverse arguments
∨  (any a, any b) -> num               = logical OR
⟇  (any a, any b) -> num               = logical OR with reverse arguments
÷  (num a, num b) -> num               = a / b # division
   (num a, str b) -> [str]             = b split into a even length pieces. There may be an extra part if the string is too long.
   (str a, num b) -> [str]             = a split into b even length pieces. There may be an extra part if the string is too long.
   (str a, str b) -> [str]             = a.split_on_first_occurance(b)
   (otherwise)                         = vectorise
×  (num a, num b) -> num               = a × b # multiply, multiplication, times
   (num a, str b) -> str               = b repeated a times
   (str a, num b) -> str               = a repeated b times
   (str a, str b) -> [str]             = [char + b for char in a]
   (otherwise)                         = vectorise
«                                      = base-255 compressed string - «...«
<newline>                              = NOP # no-op, nothing
»                                      = base-255 compressed number - »...»
°                                      = function reference - °defined_function_name;
•  (num a, num b) -> num               = log_a(b)
   (num a, str b) -> [str]             = [char * a for char in b]
   (str a, num b) -> [str]             = [char * b for char in a]
   (str a, str b) -> str               = a.with_capitalisation_of(b)
   ([any] a, [any] b) -> [any]         = a molded to the shape of b
   (otherwise) -> [any]                = vectorise
¿  (any a, any b?) -> any              = apply element if a is truthy - <element>¿
⋄  (num a) -> num                      = number of prime factors
   (str a) -> any                      = execute as Vyxal
   (fun a, any... b) -> any            = call function
   ([any]) -> [any]                    = vectorise
μ                                      = last element as a function - <element>μ
ξ                                      = last two elements as a single element - <element><element>ξ
π                                      = last three elements as a single element - <element><element><element>π
ρ                                      = last four elements as a single element - ....ρ
ς  (any a) -> [any]                    = inner product - <element>ς
σ  (any a) -> [any]                    = outer product - <element>σ
φ  (any a) -> [any]                    = repeat element infinitely, returning a generator - <element>φ
χ                                      = everything to the start of the line as a single element
ψ  (any a, any b?, any c?) -> any, any = apply last two elements "parallel" - 3 4 +-ψ -> 7, -1
ω  (any a, any b?, any c?) -> [any]    = apply last two elements "parallel" and collect - equivalent to ψ"
ɓ                                      = last element double vectorised - <element>ɓ
ƈ  (any a) -> [any]                    = collect while applying last element is truthy - <element>ƈ
ɗ  ([any] a) -> any                    = maximum by last element - <element>ɗ
ƒ  ([any] a) -> [any]                  = filter by last element - <element>ƒ
ɠ  ([any] a) -> [any]                  = minimum by last element - <element>ɠ
ɦ  ([any] a) -> [any]                  = map last element over prefixes - <element>ɦ
<space>                                = NOP
!  (num a)                             = factorial(a)
   (str a)                             = sentence_case(a)
   ([any] a)                           = vectorise
"  (any a, any b) -> [any]             = [a, b] (pair items)
#                                      = comment
$  (any a, any b) -> any, any          = b, a (swap items)
%  (num a, num b) -> num               = a % b # modulo
   (num a, str b) -> str               = (b split into a equal pieces)[-1]
   (str a, num b) -> str               = (a split into b equal pieces)[-1]
   (str a, str b) -> str               = a.format(b)
   (str a, [any] b) -> str             = a.format(b)
   (otherwise) -> [any]                = vectorise
&                                      = apply last element to the register - <element>&
'                                      = single character string
(                                      = open for loop: (variable|...)
)                                      = close for loop
*  (num a, num b) -> num               = a ** b # exponent, exponentiation
   (num a, str b) -> str               = every ath letter of b
   (str a, num b) -> str               = every bth letter of a
   (str a, str b) -> [num]             = regex.search(pattern=a, string=b).span()
   (otherwise) -> [any]                = vectorise
+  (num a, num b) -> num               = a + b # addition
   (num a, str b) -> str               = concat(a, b)
   (str a, num b) -> str               = concat(a, b)
   (str a, str b) -> str               = concat(a, b)
   (otherwise) -> [any]                = vectorised
,  (any a)                             = print(a)
-  (num a, num b) -> num               = a - b # subtraction
   (num a, str b) -> str               = ("-" × a) + b
   (str a, num b) -> str               = a + ("-" × b)
   (str a, str b) -> str               = a.remove(b)
   (otherwise) -> [any]                = vectorise
.                                      = decimal seperator
/  (any a)                             = reduce by last element - <element>/
0                                      = numeric literal
1                                      = numeric literal
2                                      = numeric literal
3                                      = numeric literal
4                                      = numeric literal
5                                      = numeric literal
6                                      = numeric literal
7                                      = numeric literal
8                                      = numeric literal
9                                      = numeric literal
:  (any a) -> any, any                 = a, a  # duplicate
;                                      = closes a structure
<  (num a, num b) -> num               = a < b (less than)
   (num a, str b) -> num               = str(a) < b
   (str a, num b) -> num               = a < str(b)
   (str a, str b) -> num               = a < b (python string less than)
   ([any] a, scl b) -> [num]           = [n < b for n in a]
   ([any] a, [any] b) -> [num]         = [a[n] < b[n] for n in range(len(a))]
=  (scl a, scl b) -> num               = a == b
   ([any] a, scl b) -> [num]           = a == b # vectorising equals
   ([any] a, [any] b) -> [num]         = a == b # vectorise element wise
<  (num a, num b) -> num               = a < b (less than)
   (num a, str b) -> num               = str(a) < b
   (str a, num b) -> num               = a < str(b)
   (str a, str b) -> num               = a < b (python string less than)
   ([any] a, scl b) -> [num]           = [n < b for n in a]
   ([any] a, [any] b) -> [num]         = [a[n] < b[n] for n in range(len(a))]
?  -> any                              = input()
@                                      = define a function: @name:parameters|...;
                                       = call a function: @name;
A  ([any] a) -> num                    = all(a)
B  (scl a) -> num                      = int(a, 2)
   ([any] a) -> [num]                  = vectorise
C  (num a) -> str                      = chr(a)
   (str a) -> num OR [num]             = ord(a) if len(a) == 1 else map(ord, a)
   (otherwise) -> [any]                = vectorise
D  (any a) -> any, any, any            = a, a, a (triplicate)
E  (num a) -> num                      = 2 ** a # 2 power, two power
   (str a) -> any                      = eval(a)
   (otherwise) -> [any]                = vectorise
F  (val a, val b) -> any               = remove elements of a that are in b
   ([any] a, fun b) -> [any]           = filter(b, a) # filter, keep, python filter
   (fun a, [any] b) -> [any]           = filter(a, b) # filter, keep, python filter
G  ([any] a) -> any                    = max(a) # monadic maximum, maximum iterable
H  ([any] a) -> any                    = a[0]
I  (num a) -> num                      = int(a)
   (str a) -> num                      = int(a)
   ([any] a) -> num                    = int(a) using list items as digits
J  ([any] a, scl b) -> [any]           = a.append(b) # Append
   (scl a, [any] b) -> [any]           = b.prepend(a) # Prepend
   ([any] a, [any] b) -> [any]         = merged(a, b) # Merge
   (scl a, scl b) -> scl               = concatenated(a, b) # Concatenate
K  (num a) -> [num]                    = divisors(a)
   (str a) -> [str]                    = prefixes(a)
   (otherwise) -> [any]                = prefixes(a)
L  (any a) -> num                      = len(a)
M  (val a, val b) -> [[any, any]]      = [[a, item] for item in b] # Vectorised pair
   ([any] a, fun b) -> [any]           = map(b, a)
   (fun a, [any] b) -> [any]           = map(a, b)
N  (num a) -> num                      = -a (negate)
   (str a) -> str                      = swapcase(a)
   ([any] a) -> [any]                  = vectorise
O  (any a, any b) -> num               = a.count(b) (non-vectorising)
P  (any a, any b) -> [any]             = prepend b to a
Q                                      = stop execution (quit)
R  (val a, val b) -> any, [any]        = a, vectorised_reverse(b)
   ([any] a, fun b) -> [any]           = reduce a by b # reduction, reduce
   (fun a, [any] b) -> [any]           = reduce b by a # reduction, reduce
S  (num a) -> str                      = str(a)
   (str a) -> [str]                    = a.splitlines()
   ([any] a) -> [any]                  = vectorise
T  (any a) -> any                      = a[-1]
U  (any a) -> [any]                    = uniquifed(a) # uniquify, unique items
V  (any a, any b, any c) -> [any]      = a.replace(b, c)
W  (any a) -> [any]                    = [a] # wrap item
X  (num a) -> num                      = random.choice(range(a))
   (str a) -> str                      = random.choice(a)
   ([any] a) -> any                    = random.choice(a)
Y  (any a) -> [any], [any]             = uninterleave(a)
Z  (any a, any b) -> [[any, any]]      = zip(a, b)
   (any a, fun b) -> [any]             = zip(a, map(b, a)) #zipmap, map and zip
[                                      = open if statement: [truthy|falsey]
\                                      = cumulative reduce by last element - <element>\
]                                      = close if statement
`                                      = string - `...`
^                                      = reverse stack
_  (any a)                             = discard/pop/trash
a  (any a) -> num                      = any(a)
b  (num a) -> [num]                    = binary repr of a
   (str a) -> [[num]]                  = [bin(ord(char)) for char in a]
   ([any] a) -> [any]                  = vectorise
c  (any a, any b) -> num               = a in b (contains)
d  (num a) -> num                      = a × 2
   (str a) -> str                      = a + a
   ([any] a) -> [any]                  = vectorise
e  (num a, num b) -> [num, num]        = [a + b, a - b]
   (num a, str b) -> [str]             = Split b into two sections, the first of which has length a.
   (str a, num b) -> [str]             = Split a into two sections, the first of which has length b.
   (str a, str b) -> [str]             = Split a on the first occurance of b
   (fun a, num b) -> [num]             = first b integers where a() is truthy
   (num a, fun b) -> [num]             = first a integers where b() is truthy
   (otherwise) -> [any]                = vectorise
f  (num a) -> [num]                    = list of a's digits
   (str a) -> [str]                    = list of a's characters
   (otherwise) -> [any]                = flattened(a) # flatten, deep flatten
g  ([any] a) -> any                    = min(a) # monadic minimum, minimum iterable
h  (any a, num b) -> [any]             = a[0:b] # Slice until b
   (str a, str b) -> [any]             = regex.findall(pattern=a, string=b) # re.findall
   (otherwise) -> [any]                = vectorise
i  (any a, num b) -> any               = a[b] # index
   (any a, [num] b)                    = a[:b] # 0 to bth item of a, use t for a[b:], needs wrapping index
   (any a, [num x, num y] b)           = a[x:y] # index, xth to yth item, needs wrapping index
   (any a, [num x, num y, num m] b)    = a[x:y:m] # index, xth to yth item step m items, needs wrapping index
j  (any a, any b) -> str               = a.join(b)
k                                      = constant digraphs (see near the end of docs)
l  (any a, num b) -> [[any]]           = n-wise_group(a, b) # Cummulative grouping/pairing
   (any a, [any] b) -> num             = length(a) == length(b) # Length of a and b are same?
m  (any a)                             = mirror(a) # numbers are reversed and added
n                                      = context variable
o  (num a, num b) -> num               = how many times does b divide a?  # order
   (num a, str b) -> str               = a * a grid of b, joined with newlines
   (str a, num b) -> str               = b * b grid of a, joined with newlines
   (str a, str b) -> str               = remove b from a until a does not change
   (otherwise) -> [any]                = vectorise
p  (num a, num b) -> [num]             = range(a, b + 1)  # inclusive range from a to b
   (num a, str b) -> [str]             = cartesian_power(b, times=a)
   (str a, num b) -> [str]             = cartesian_power(a, times=b)
   (num a, [any] b) -> [any]           = cartesian_power(b, times=a)
   ([any] a, num b) -> [any]           = cartesian_power(a, times=b)
   (str a, str b) -> str               = a.strip(b)
   (otherwise) -> [any]                = vectorise
q  (any a) -> str                      = "`" + a + "`" # uneval, quotify
r  (num a, num b) -> [num]             = range(a, b) # Exclusive range from a to b
   (num a, str b) -> str               = stretch left; repeat the first character of b enough times to make it at least length a. Use spaces if b is empty.
   (str a, num b) -> str               = stretch left; repeat the first character of a enough times to make it at least length b. Use spaces if a is empty.
   (any a, fun b) -> [any]             = cumulative_reduce(a, function=b) # also works with (fun a, any b), Cumulative reduce
   (otherwise) -> num                  = regex.has_match(pattern=a, string=b) # regex match
s  (any a) -> any                      = sorted(a) # min → max, sort
t  (any a, num b) -> [any]             = a[b:] # slice from b
   (str a, str b) -> [any]             = regex.match(pattern=a, string=b).groups() # regex groups
   (otherwise) -> [any]                = vectorise
u  ([any] a, num b) -> [any]           = rotate a b units to the left
   (any a, [any] b) -> any, [any]      = a, b rotated to the left once
v                                      = vectorise last element - <element>v
w  (any a, num b) -> [any]             = a wrapped in chunks of length b
   (any a, str b) -> [any]             = split a on b, discarding empty items
   ([any] a, fun b) -> [any]           = apply b to every second item of a
   (fun a, [any] b) -> [any]           = apply a to every second item of b
x                                      = call current function # recursion. Prints entire stack if not in a function/lambda
y  (any a, any b) -> any               = interleave(a, b) # Interleave
z  (any a) -> [any]                    = zip(a, a)
{                                      = open while loop: {condition|...}
|                                      = branch in structure (syntax), Used to seperate blocks in If/For/While/Lambda/Function definition
}                                      = close while loop
~                                      = execute element without popping - <element>~
½  (num a) -> num                      = a / 2 # half, halve
   (str a)  -> [str]                   = a split into two strings of equal lengths (as close as possible)
   ([any] a) -> [any]                  = vectorised
Ȧ  ([any] a, num b, any c) -> [any]    = a[b] = c
Ḃ  (any a) -> any, any                 = a, reversed(a)
Ċ  (num a, num b) -> [num, num]        = [a + b, a - b]
   (num a, str b) -> str               = diagonal of char b of length a - 5`/`Ċ -> `    /\n   / \n  / \n /   \n/    `
   (str a, num b) -> str               = diagonal of char a of length b
   (str a, str b) -> str               = a.partition(b)
   ([any] a, scl b) -> [num]           = b in a (vectorised)
   (scl a, [any] b) -> [num]           = a in b (vectorised)
   ([any] a, [any] b) -> [num]         = [n in a for n in b]
Ḋ  (num a, num b) -> num               = a % b == 0
   (num a, str b) -> str               = anti-diagonal of char b of length a - 5`/`Ḋ -> `/    \n /   \n  /  \n   / \n    /`
   (str a, num b) -> str               = diagonal of char b of length a
   (str a, str b) -> str               = overwrite the start of a with b -> `abcdef` `Joe`Ḋ -> `Joedef`
   (otherwise) -> [any]                = vectorise
Ė  (num a, num b) -> num               = a // b (integer divide)
   (str a, str b) -> str               = b + a + b (surround)
   (otherwise) -> [any]                = vectorise
Ḟ  (any a, any b) -> num               = a.find(b)
Ġ  (num a) -> num                      = 1 / a
   (str a) -> [str]                    = a split into int(sqrt(a)) parts
   ([any] a) -> [any]                  = vectorise
Ḣ  ([any] a) -> [any]                  = a[1:b]
İ  (num a) -> num                      = proper divisor count
   (str a) -> str                      = GET request with url=a
   ([any] a) -> [any]                  = matrix inverse of a
Ŀ  (any a, any b, any c) -> any        = transliterate(a, b, c) # Transliterate
   (fun a, fun b, any c) -> any        = repeat_until_false(predicate=a, modifying_function=b, inital=c) # equivalent to ẋt
Ṁ  (num a, num b) -> [num]             = roots of quadratic ax^2 + bx = 0 # Solve quadratic equation
   (num a, str b) -> num               = evaluate single variable equation b with x=a
   (str a, num b) -> num               = evaluate single variable equation a with x=b
   (str a, str b) -> num               = set(a) == set(b) # Check if two lists are same except duplicates
   ([any] a, [any] b) -> [any]         = matrix multiply a and b
   (fun a, [any] b) -> any             = right reduce b by a # foldr
   ([any] a, fun b) -> any             = right reduce a by b # foldr
   (otherwise) -> [any]                = vectorised
Ṅ  (num a) -> [num]                    = integer_paritions(a) # Integer partitions
   (str a) -> str                      = insert spaces between characters
   ([any] a) -> str                    = join on spaces
   (fun a) -> num                      = first integer where a(x) is truthy
Ȯ  (num a) -> num                      = log_2(a)
   (str a) -> str                      = remove all non-alphanumeric characters from a
   ([any] a) -> [any]                  = sums of rows (∑v)
Ṗ  (any a) -> [any]                    = permutations(a) # Permutations
Ṙ  (any a) -> any                      = reverse a
Ṡ  (num a) -> [num]                    = list from −abs(a) to abs(a) inclusive
   (str a) -> any                      = exec(a) # Execute python code, Python exec
   ([any] a) -> [any]                  = sums of columns of a
Ṫ  (num a) -> num                      = len(prime_factors(a)) # Number of prime factors
   (str a) -> str                      = read from file a
   ([any] a) -> [any]                  = transpose a
Ẇ  (num a, num b) -> [num]             = a * b array of 0s
   (num a, str b) -> str               = stretch right; repeat the first character of b enough times to make it at least length a. Use spaces if b is empty.
   (str a, num b) -> str               = stretch right; repeat the first character of a enough times to make it at least length b. Use spaces if a is empty.
   (str a, str b) -> num               = insert b between each character of a
   ([any] a, [any] b) -> [any]         = dot product of a and b
   ([any] a, fun b) -> [any]           = map b over prefixes of a
   (fun a, [any] b) -> [any]           = map a over prefixes of b
   (otherwise) -> [any]                = vectorise
Ẋ  ([any] a, [any] b) -> [any]         = cartesian product
   ([any] a, fun b) -> [any]           = map b over suffixes of a
   (fun a, [any] b) -> [any]           = map a over suffixes of b
Ẏ  ([any] a) -> [any]                  = cartesian product with self (:Ẋ)
Ż  ([any] a) -> [any]                  = zip(a, a)
ȧ  (num a) -> num                      = abs(a)
   (str a) -> str                      = remove whitespace from a
   ([any] a) -> [any]                  = vectorise
ḃ  (num a) -> num                      = a != 0
   (str a) -> num                      = len(a) != 0
   ([any] a) -> [num]                  = vectorise
ċ  (num a, num b) -> num               = a choose b
   (num a, str b) -> [str]             = l but sublists are joined as a string instead
   (str a, num b) -> [str]             = l but sublists are joined as a string instead
   (str a, str b) -> str               = replace spaces in a with b
   (otherwise) -> [any]                = vectorise
ḋ  (num a, num b) -> [num]             = [a / b, a % b]  # divmod, div mod, [div, mod], Quotient and modulo
   ([any] a, num b) -> [any]           = combinations of a with length b
   (num a, [any] b) -> [any]           = combinations of b with length a
   (str a, str b) -> str               = a.trim(b)
ė  (any a) -> [any]                    = enumerate(a) # :ʀZ
ḟ  (fun a, [any] b) -> [any]           = push Generator of function a with initial vector b
   (fun a, [any] b, num c) -> [any]    = push Generator of function a with initial vector b, limited to c items (if present)
ġ  (num a) -> num                      = (e ** a) - 1 # uses math.expm1()
   (otherwise) -> [any]                = format a as grid
ḣ  (num a) -> str                      = a to base 16
   (str a) -> num                      = a from base 16
   (otherwise) -> [any]                = vectorise
ŀ  (num a, num b, num c) -> num        = a <= c <= b
   (num a, num b, str c) -> str        = a by b grid of c
   (num a, str b, num c) -> str        = a by c grid of b
   (num a, str b, str c) -> str        = b.ljust(a,filler=c)
   (str a, num b, num c) -> str        = b by c grid of a
   (str a, num b, str c) -> str        = a.ljust(c,filler=b)
   (str a, str b, num c) -> str        = a.ljust(b,filler=c)
   (str a, str b, str c) -> str        = a.infinite_replace(b, c)
   (otherwise) -> [any]                = vectorise
ṁ
ṅ
ȯ
ṗ
ṙ
ṡ
ṫ
ẇ
ẋ
ẏ
ż
≤
≥
≠
⁼
©
®
∞
₀
₁
₂
₃
₄
₅
₆
₇
₈
₉
⁰
¹
²
³
⁴
⁵
∑
¦
⌈
⌊
¯
±
↳
↲
⋏
⋎
꘍
ꜝ
”
‡
⇧
⇩
∆
ø
Þ
¨
‘
“
ð
□
↑
↓
∴
∵
›
‹
β
τ
¶
§
ε
ʀ
ʁ
ɾ
ɽ
Π
⁽
↕
⁾
⁺
Ɓ
Ƈ
Ɗ
Ƒ
Ɠ
Ƙ
Ɱ
Ɲ
Ƥ
Ƭ
Ʋ
Ȥ
δ
⟨
⟩
->
←
∪
∩
⊍
